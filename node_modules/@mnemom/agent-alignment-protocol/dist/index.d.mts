/**
 * Alignment Card schema - Agent alignment declaration.
 *
 * Defines the Alignment Card structure per SPEC Section 4. An Alignment Card
 * is a structured document declaring an agent's alignment posture.
 *
 * @see SPEC.md Section 4 for complete specification.
 */
/** Type of principal the agent serves. */
type PrincipalType = "human" | "organization" | "agent" | "unspecified";
/** Nature of authority delegation from principal to agent. */
type RelationshipType = "delegated_authority" | "advisory" | "autonomous";
/** How value conflicts are resolved. */
type HierarchyType = "lexicographic" | "weighted" | "contextual";
/** Action to take when escalation trigger matches. */
type TriggerAction = "escalate" | "deny" | "log";
/** Audit log storage type. */
type StorageType = "local" | "remote" | "distributed";
/** Tamper-evidence mechanism for audit logs. */
type TamperEvidence = "append_only" | "signed" | "merkle";
/** Principal relationship declaration (SPEC Section 4.3). */
interface Principal {
    /** Type of principal */
    type: PrincipalType;
    /** Principal identifier (DID, email, org ID) */
    identifier?: string | null;
    /** Nature of authority delegation */
    relationship: RelationshipType;
    /** Endpoint for escalation notifications */
    escalation_contact?: string | null;
}
/** Definition of a custom value. */
interface ValueDefinition {
    /** Human-readable name */
    name: string;
    /** What this value means operationally */
    description: string;
    /** Priority for lexicographic ordering (higher = more important) */
    priority?: number;
}
/** Value declarations (SPEC Section 4.4). */
interface Values {
    /** List of value identifiers */
    declared: string[];
    /** Definitions for non-standard values */
    definitions?: Record<string, ValueDefinition> | null;
    /** Values this agent refuses to coordinate with */
    conflicts_with?: string[] | null;
    /** How value conflicts are resolved */
    hierarchy?: HierarchyType | null;
}
/** Condition that triggers escalation (SPEC Section 4.5). */
interface EscalationTrigger {
    /** Condition expression (see SPEC Section 4.6) */
    condition: string;
    /** Action to take when trigger matches */
    action: TriggerAction;
    /** Human-readable explanation */
    reason: string;
}
/** Monetary value specification. */
interface MonetaryValue {
    /** Numeric amount */
    amount: number;
    /** ISO 4217 currency code */
    currency?: string;
}
/** Autonomy bounds and escalation triggers (SPEC Section 4.5). */
interface AutonomyEnvelope {
    /** Actions permitted without escalation */
    bounded_actions: string[];
    /** Conditions requiring escalation */
    escalation_triggers: EscalationTrigger[];
    /** Maximum transaction value without escalation */
    max_autonomous_value?: MonetaryValue | null;
    /** Actions never permitted */
    forbidden_actions?: string[] | null;
}
/** Audit log storage configuration. */
interface AuditStorage {
    /** Storage type */
    type: StorageType;
    /** Storage endpoint or location */
    location?: string | null;
}
/** Audit trail commitments (SPEC Section 4.7). */
interface AuditCommitment {
    /** Trace format identifier */
    trace_format?: string;
    /** Minimum retention period in days */
    retention_days: number;
    /** Storage configuration */
    storage?: AuditStorage | null;
    /** Whether traces can be queried externally */
    queryable: boolean;
    /** Endpoint for trace queries (required if queryable=true) */
    query_endpoint?: string | null;
    /** Tamper-evidence mechanism */
    tamper_evidence?: TamperEvidence | null;
}
/**
 * Alignment Card - Agent alignment declaration (SPEC Section 4).
 *
 * A structured document declaring an agent's alignment posture. It MUST be
 * machine-readable (JSON) and SHOULD be human-readable.
 */
interface AlignmentCard {
    /** AAP specification version */
    aap_version?: string;
    /** Unique identifier for this card (UUID or URI) */
    card_id: string;
    /** Identifier for the agent (DID, URL, or UUID) */
    agent_id: string;
    /** When this card was issued (ISO 8601) */
    issued_at: string;
    /** When this card expires (ISO 8601) */
    expires_at?: string | null;
    /** Principal relationship declaration */
    principal: Principal;
    /** Value declarations */
    values: Values;
    /** Autonomy bounds and escalation triggers */
    autonomy_envelope: AutonomyEnvelope;
    /** Audit trail commitments */
    audit_commitment: AuditCommitment;
    /** Protocol-specific extensions */
    extensions?: Record<string, unknown> | null;
}
/** Check if an alignment card has expired. */
declare function isCardExpired(card: AlignmentCard): boolean;
/** Check if a value is declared in the card. */
declare function hasValue(card: AlignmentCard, value: string): boolean;
/** Check if an action is in the bounded actions list. */
declare function isActionBounded(card: AlignmentCard, action: string): boolean;
/** Check if an action is forbidden. */
declare function isActionForbidden(card: AlignmentCard, action: string): boolean;

/**
 * AP-Trace schema - Audit log format for agent decisions.
 *
 * Defines the AP-Trace structure per SPEC Section 5. An AP-Trace entry
 * records an agent's decision process.
 *
 * @see SPEC.md Section 5 for complete specification.
 */
/** Type of action taken or considered. */
type ActionType = "recommend" | "execute" | "escalate" | "deny";
/** How the action relates to the autonomy envelope. */
type ActionCategory = "bounded" | "escalation_trigger" | "forbidden";
/** Status of an escalation. */
type EscalationStatus = "pending" | "approved" | "denied" | "timeout";
/** Resource affected by the action. */
interface ActionTarget {
    /** Resource type */
    type: string;
    /** Resource identifier */
    identifier: string;
}
/** Action taken or considered (SPEC Section 5.4). */
interface Action {
    /** Action type */
    type: ActionType;
    /** Human-readable action name */
    name: string;
    /** How this action relates to autonomy envelope */
    category: ActionCategory;
    /** Resource affected */
    target?: ActionTarget | null;
    /** Action parameters */
    parameters?: Record<string, unknown> | null;
}
/** An alternative considered during decision-making. */
interface Alternative {
    /** Unique identifier for this option */
    option_id: string;
    /** Human-readable description */
    description: string;
    /** Computed score (0.0 to 1.0) */
    score?: number | null;
    /** Breakdown of score components */
    scoring_factors?: Record<string, number> | null;
    /** Concerns or flags about this option */
    flags?: string[] | null;
}
/** Decision process record (SPEC Section 5.5). */
interface Decision {
    /** Options evaluated (minimum 1) */
    alternatives_considered: Alternative[];
    /** Option ID selected */
    selected: string;
    /** Human-readable explanation of why this was chosen */
    selection_reasoning: string;
    /** Values that influenced this decision */
    values_applied: string[];
    /** Decision confidence (0.0 to 1.0) */
    confidence?: number | null;
}
/** Record of checking an escalation trigger. */
interface TriggerCheck {
    /** Trigger condition that was checked */
    trigger: string;
    /** Whether the trigger matched */
    matched: boolean;
    /** Observed value (for comparison triggers) */
    value_observed?: unknown | null;
}
/** Response from principal to escalation. */
interface PrincipalResponse {
    /** Principal's decision */
    decision: string;
    /** When decision was made (ISO 8601) */
    timestamp: string;
    /** Conditions attached to approval */
    conditions?: string[] | null;
}
/** Escalation evaluation record (SPEC Section 5.6). */
interface Escalation {
    /** Whether escalation was evaluated */
    evaluated: boolean;
    /** Triggers that were evaluated */
    triggers_checked?: TriggerCheck[] | null;
    /** Whether escalation is required */
    required: boolean;
    /** Human-readable explanation */
    reason: string;
    /** Escalation request ID (if escalation required) */
    escalation_id?: string | null;
    /** Status of escalation (if escalation required) */
    escalation_status?: EscalationStatus | null;
    /** Principal's response (if escalation required) */
    principal_response?: PrincipalResponse | null;
}
/** Additional context for the trace (SPEC Section 5.7). */
interface TraceContext {
    /** Session identifier */
    session_id?: string | null;
    /** Turn number in conversation */
    conversation_turn?: number | null;
    /** IDs of related prior traces */
    prior_trace_ids?: string[] | null;
    /** Environment metadata (client, locale, etc.) */
    environment?: Record<string, unknown> | null;
    /** Additional arbitrary metadata */
    metadata?: Record<string, unknown> | null;
}
/**
 * AP-Trace - Audit log entry for agent decisions (SPEC Section 5).
 *
 * An AP-Trace records an agent's decision process, enabling verification
 * that observed behavior is consistent with declared alignment.
 */
interface APTrace {
    /** Unique identifier (UUID) */
    trace_id: string;
    /** Agent that generated this trace */
    agent_id: string;
    /** Alignment Card in effect */
    card_id: string;
    /** When this trace was created (ISO 8601) */
    timestamp: string;
    /** Action taken or considered */
    action: Action;
    /** Decision process record */
    decision: Decision;
    /** Escalation evaluation (if applicable) */
    escalation?: Escalation | null;
    /** Additional context */
    context?: TraceContext | null;
}
/** Get the selected alternative from the decision. */
declare function getSelectedAlternative(trace: APTrace): Alternative | undefined;
/** Check if this decision was escalated. */
declare function wasEscalated(trace: APTrace): boolean;
/** Check if the action was forbidden or triggered unhandled escalation. */
declare function hadViolations(trace: APTrace): boolean;

/**
 * Verification and drift detection models.
 *
 * Defines the result types for AAP verification operations as specified
 * in SPEC.md Sections 7 (Verification) and 8 (Drift Detection).
 */
/** Types of verification violations (SPEC Section 7.5). */
type ViolationType = "unbounded_action" | "forbidden_action" | "missed_escalation" | "undeclared_value" | "card_expired" | "card_mismatch";
/** Violation severity levels. */
type Severity = "critical" | "high" | "medium" | "low";
/** Mapping of violation types to their severity */
declare const VIOLATION_SEVERITY: Record<ViolationType, Severity>;
/** A single verification violation. */
interface Violation {
    /** Type of violation */
    type: ViolationType;
    /** Severity level */
    severity: Severity;
    /** Human-readable description */
    description: string;
    /** JSON path to the violating field */
    trace_field?: string | null;
}
/** Create a violation with automatic severity lookup. */
declare function createViolation(type: ViolationType, description: string, traceField?: string | null): Violation;
/** A verification warning (non-critical issue). */
interface Warning {
    /** Warning type identifier */
    type: string;
    /** Human-readable description */
    description: string;
    /** JSON path to the relevant field */
    trace_field?: string | null;
}
/** Metadata about the verification process. */
interface VerificationMetadata {
    /** Verification algorithm version */
    algorithm_version: string;
    /** List of checks that were performed */
    checks_performed: string[];
    /** Time taken to perform verification in milliseconds */
    duration_ms?: number | null;
}
/** Result of verifying an AP-Trace against an Alignment Card (SPEC Section 7.4). */
interface VerificationResult {
    /** True if no violations were found */
    verified: boolean;
    /** ID of the verified trace */
    trace_id: string;
    /** ID of the Alignment Card used */
    card_id: string;
    /** When verification was performed (ISO 8601) */
    timestamp: string;
    /** List of violations found */
    violations: Violation[];
    /** List of non-critical warnings */
    warnings: Warning[];
    /** Metadata about the verification process */
    verification_metadata: VerificationMetadata;
}
/** Categories of behavioral drift (SPEC Section 8.5). */
type DriftDirection = "autonomy_expansion" | "value_drift" | "principal_misalignment" | "communication_drift" | "unknown";
/** A specific indicator of behavioral drift. */
interface DriftIndicator {
    /** Indicator identifier */
    indicator: string;
    /** Expected/baseline value */
    baseline: number;
    /** Currently observed value */
    current: number;
    /** Human-readable explanation */
    description: string;
}
/** Detailed analysis of detected drift. */
interface DriftAnalysis {
    /** Current similarity to declared alignment (0.0 to 1.0) */
    similarity_score: number;
    /** Number of consecutive low-similarity traces */
    sustained_traces: number;
    /** Similarity threshold used */
    threshold: number;
    /** Categorized direction of drift */
    drift_direction: DriftDirection;
    /** Specific drift indicators */
    specific_indicators: DriftIndicator[];
}
/** Alert generated when sustained drift is detected (SPEC Section 8.4). */
interface DriftAlert {
    /** Type of alert */
    alert_type: "drift_detected";
    /** Agent exhibiting drift */
    agent_id: string;
    /** Alignment Card being drifted from */
    card_id: string;
    /** When drift was detected (ISO 8601) */
    detection_timestamp: string;
    /** Drift analysis details */
    analysis: DriftAnalysis;
    /** Recommended action */
    recommendation: string;
    /** IDs of traces exhibiting drift */
    trace_ids: string[];
}
/** Analysis of value alignment between two cards. */
interface ValueAlignment {
    /** Values present in both cards */
    matched: string[];
    /** Values in one card but not the other */
    unmatched: string[];
    /** Direct value conflicts */
    conflicts: ValueConflictResult[];
}
/** A conflict between values declared by two agents. */
interface ValueConflictResult {
    /** Value from initiating agent */
    initiator_value: string;
    /** Value from responding agent */
    responder_value: string;
    /** Type of conflict (incompatible, priority_mismatch, etc.) */
    conflict_type: string;
    /** Human-readable explanation */
    description: string;
}
/** Result of checking value coherence between two Alignment Cards. */
interface CoherenceResult {
    /** Whether the cards are compatible for coordination */
    compatible: boolean;
    /** Coherence score (0.0 to 1.0) */
    score: number;
    /** Detailed value alignment analysis */
    value_alignment: ValueAlignment;
    /** Whether to proceed with coordination */
    proceed: boolean;
    /** Conditions for proceeding (if any) */
    conditions: string[];
    /** Proposed conflict resolution (if conflicts exist) */
    proposed_resolution?: {
        type: string;
        reason: string;
    } | null;
}

/**
 * AAP Verification API - The three public entry points.
 *
 * This module provides the core verification functionality:
 * - verifyTrace: Verify a single AP-Trace against an Alignment Card
 * - checkCoherence: Check value coherence between two Alignment Cards
 * - detectDrift: Detect behavioral drift from declared alignment over time
 *
 * @see SPEC.md Sections 7, 6.4, and 8 for protocol specification.
 */

/**
 * Verify a single AP-Trace against an Alignment Card.
 *
 * Performs the verification algorithm specified in SPEC Section 7.3:
 * 1. Autonomy compliance - action category matches autonomy envelope
 * 2. Escalation compliance - required escalations were performed
 * 3. Value consistency - applied values match declared values
 * 4. Forbidden action compliance - no forbidden actions taken
 *
 * @param trace - AP-Trace to verify
 * @param card - Alignment Card to verify against
 * @returns VerificationResult with violations and warnings
 */
declare function verifyTrace(trace: APTrace, card: AlignmentCard): VerificationResult;
/**
 * Check value coherence between two Alignment Cards.
 *
 * Computes coherence score as specified in SPEC Section 6.4:
 *     score = (matched / required) * (1 - conflict_penalty)
 * where conflict_penalty = 0.5 * (conflicts / required)
 *
 * @param myCard - Initiator's Alignment Card
 * @param theirCard - Responder's Alignment Card
 * @param taskValues - Optional list of values required for the task
 * @returns CoherenceResult with compatibility assessment
 */
declare function checkCoherence(myCard: AlignmentCard, theirCard: AlignmentCard, taskValues?: string[]): CoherenceResult;
/**
 * Detect behavioral drift from declared alignment.
 *
 * Computes a baseline centroid from the first N traces, then compares
 * subsequent traces against this centroid using cosine similarity.
 * Trace-to-trace comparison provides symmetric feature spaces, yielding
 * meaningful similarity scores (unlike trace-to-card which is structurally
 * depressed due to asymmetric features).
 *
 * Alerts when sustained low similarity is detected (consecutive traces
 * below threshold).
 *
 * @see SPEC Section 8 and Appendix B.2 for algorithm specification.
 *
 * @param card - Alignment Card (used for card_id and direction inference)
 * @param traces - List of AP-Traces (sorted chronologically internally)
 * @param similarityThreshold - Alert when similarity drops below (default: 0.30)
 * @param sustainedThreshold - Alert after N consecutive low-similarity traces (default: 3)
 * @returns List of DriftAlert objects for detected drift events
 */
declare function detectDrift(card: AlignmentCard, traces: APTrace[], similarityThreshold?: number, sustainedThreshold?: number): DriftAlert[];

/**
 * Value Coherence Handshake messages - Agent-to-agent alignment verification.
 *
 * Defines the message types for the Value Coherence Handshake protocol
 * per SPEC Section 6.
 *
 * @see SPEC.md Section 6 for complete specification.
 */

/** Information about the agent making a request. */
interface RequesterInfo {
    /** Agent identifier (DID, URL, or UUID) */
    agent_id: string;
    /** Requester's Alignment Card ID */
    card_id: string;
}
/** Context about the task for which alignment is being checked. */
interface TaskContext {
    /** Type of task being proposed */
    task_type: string;
    /** Values required for this task */
    values_required?: string[] | null;
    /** Categories of data involved */
    data_categories?: string[] | null;
}
/** Request for an agent's Alignment Card (SPEC Section 6.3.1). */
interface AlignmentCardRequest {
    /** Message type identifier */
    message_type?: "alignment_card_request";
    /** Unique request identifier */
    request_id: string;
    /** Information about requesting agent */
    requester: RequesterInfo;
    /** Context about the proposed task */
    task_context?: TaskContext | null;
    /** When request was made (ISO 8601) */
    timestamp?: string;
}
/** Cryptographic signature for authentication. */
interface Signature {
    /** Signature algorithm (e.g., Ed25519) */
    algorithm: string;
    /** Base64-encoded signature */
    value: string;
    /** Key identifier */
    key_id: string;
}
/** Response with an agent's Alignment Card (SPEC Section 6.3.2). */
interface AlignmentCardResponse {
    /** Message type identifier */
    message_type?: "alignment_card_response";
    /** Request ID being responded to */
    request_id: string;
    /** Responder's Alignment Card */
    alignment_card: AlignmentCard;
    /** Optional signature for authentication */
    signature?: Signature | null;
    /** When response was made (ISO 8601) */
    timestamp?: string;
}
/** Data sharing specification for collaboration. */
interface DataSharing {
    /** Data categories initiator will share */
    from_initiator?: string[];
    /** Data categories responder will share */
    from_responder?: string[];
}
/** Scope of autonomous actions for collaboration. */
interface AutonomyScope {
    /** Actions initiator may take */
    initiator_actions?: string[];
    /** Actions responder may take */
    responder_actions?: string[];
}
/** Proposed collaboration details. */
interface ProposedCollaboration {
    /** Type of task */
    task_type: string;
    /** Values both agents should apply */
    values_intersection?: string[] | null;
    /** Data sharing specification */
    data_sharing?: DataSharing | null;
    /** Scope of autonomous actions */
    autonomy_scope?: AutonomyScope | null;
}
/** Value coherence check request (SPEC Section 6.3.3). */
interface ValueCoherenceCheck {
    /** Message type identifier */
    message_type?: "value_coherence_check";
    /** Request ID */
    request_id: string;
    /** Initiator's Alignment Card ID */
    initiator_card_id: string;
    /** Responder's Alignment Card ID */
    responder_card_id: string;
    /** Proposed collaboration details */
    proposed_collaboration: ProposedCollaboration;
    /** When check was requested (ISO 8601) */
    timestamp?: string;
}
/** A conflict between values declared by two agents. */
interface ValueConflict {
    /** Value from initiating agent */
    initiator_value: string;
    /** Value from responding agent */
    responder_value: string;
    /** Type of conflict (incompatible, priority_mismatch, etc.) */
    conflict_type: string;
    /** Human-readable explanation */
    description: string;
}
/** Detailed value alignment analysis. */
interface ValueAlignmentDetail {
    /** Values present in both cards */
    matched?: string[];
    /** Values in one card but not the other */
    unmatched?: string[];
    /** Direct value conflicts */
    conflicts?: ValueConflict[];
}
/** Coherence assessment. */
interface Coherence {
    /** Whether agents are compatible */
    compatible: boolean;
    /** Coherence score (0.0 to 1.0) */
    score: number;
    /** Detailed alignment analysis */
    value_alignment: ValueAlignmentDetail;
}
/** Proposed resolution for value conflicts. */
interface ProposedResolution {
    /** Resolution type */
    type: string;
    /** Why this resolution is proposed */
    reason: string;
    /** Alternative proposal (if applicable) */
    alternative?: Record<string, unknown> | null;
}
/** Coherence result message (SPEC Section 6.3.4). */
interface CoherenceResultMessage {
    /** Message type identifier */
    message_type?: "coherence_result";
    /** Request ID being responded to */
    request_id: string;
    /** Coherence assessment */
    coherence: Coherence;
    /** Whether to proceed with coordination */
    proceed: boolean;
    /** Conditions for proceeding (if any) */
    conditions?: string[] | null;
    /** Proposed resolution (if conflicts exist) */
    proposed_resolution?: ProposedResolution | null;
    /** When result was generated (ISO 8601) */
    timestamp?: string;
}
/** Union of all Value Coherence Handshake message types. */
type ValueCoherenceMessage = AlignmentCardRequest | AlignmentCardResponse | ValueCoherenceCheck | CoherenceResultMessage;

/**
 * Feature extraction for AAP verification.
 *
 * Provides feature extraction utilities for computing similarity
 * between AP-Traces and Alignment Cards.
 */

/** Sparse feature vector represented as a record. */
type FeatureVector = Record<string, number>;
/**
 * Extract features from an Alignment Card.
 */
declare function extractCardFeatures(card: AlignmentCard): FeatureVector;
/**
 * Extract features from an AP-Trace.
 */
declare function extractTraceFeatures(trace: APTrace): FeatureVector;
/**
 * Compute the centroid (element-wise mean) of multiple feature vectors.
 *
 * Used by drift detection to build a baseline from the first N traces,
 * enabling trace-to-trace comparison instead of trace-to-card comparison.
 *
 * @param vectors - Array of feature vectors to average
 * @returns Centroid feature vector
 */
declare function computeCentroid(vectors: FeatureVector[]): FeatureVector;
/**
 * Compute cosine similarity between two feature vectors.
 *
 * @returns Similarity score between 0.0 and 1.0
 */
declare function cosineSimilarity(a: FeatureVector, b: FeatureVector): number;

/**
 * Calibrated constants for AAP verification and drift detection.
 *
 * These thresholds were derived from empirical analysis of approximately 50
 * multi-turn agent conversations. The underlying data is not published to
 * protect deliberative privacy, but the methodology is documented in
 * docs/CALIBRATION.md.
 *
 * Implementations MAY adjust thresholds based on their own calibration data,
 * but SHOULD document the methodology used.
 */
/** Alert when behavioral similarity to declared alignment drops below this value. */
declare const DEFAULT_SIMILARITY_THRESHOLD = 0.3;
/** Alert after this many consecutive traces show low similarity. */
declare const DEFAULT_SUSTAINED_TURNS_THRESHOLD = 3;
/** Score below which an action is flagged as "near boundary" warning */
declare const NEAR_BOUNDARY_THRESHOLD = 0.35;
/** Minimum coherence score for automatic "proceed" recommendation */
declare const MIN_COHERENCE_FOR_PROCEED = 0.7;
/** Penalty multiplier for value conflicts in coherence scoring */
declare const CONFLICT_PENALTY_MULTIPLIER = 0.5;
/** Minimum word length for content features (filters noise) */
declare const MIN_WORD_LENGTH = 3;
/** Maximum features to extract from TF-IDF vectorization */
declare const MAX_TFIDF_FEATURES = 500;
declare const ALGORITHM_VERSION = "1.2.0";

export { ALGORITHM_VERSION, type APTrace, type Action, type ActionCategory, type ActionTarget, type ActionType, type AlignmentCard, type AlignmentCardRequest, type AlignmentCardResponse, type Alternative, type AuditCommitment, type AuditStorage, type AutonomyEnvelope, type AutonomyScope, CONFLICT_PENALTY_MULTIPLIER, type Coherence, type CoherenceResult, type CoherenceResultMessage, DEFAULT_SIMILARITY_THRESHOLD, DEFAULT_SUSTAINED_TURNS_THRESHOLD, type DataSharing, type Decision, type DriftAlert, type DriftAnalysis, type DriftDirection, type DriftIndicator, type Escalation, type EscalationStatus, type EscalationTrigger, type HierarchyType, MAX_TFIDF_FEATURES, MIN_COHERENCE_FOR_PROCEED, MIN_WORD_LENGTH, type MonetaryValue, NEAR_BOUNDARY_THRESHOLD, type Principal, type PrincipalResponse, type PrincipalType, type ProposedCollaboration, type ProposedResolution, type RelationshipType, type RequesterInfo, type Severity, type Signature, type StorageType, type TamperEvidence, type TaskContext, type TraceContext, type TriggerAction, type TriggerCheck, VIOLATION_SEVERITY, type ValueAlignment, type ValueAlignmentDetail, type ValueCoherenceCheck, type ValueCoherenceMessage, type ValueConflict, type ValueConflictResult, type ValueDefinition, type Values, type VerificationMetadata, type VerificationResult, type Violation, type ViolationType, type Warning, checkCoherence, computeCentroid, cosineSimilarity, createViolation, detectDrift, extractCardFeatures, extractTraceFeatures, getSelectedAlternative, hadViolations, hasValue, isActionBounded, isActionForbidden, isCardExpired, verifyTrace, wasEscalated };
